;;  Lua parser tests
;;  -*-  indent-tabs-mode:nil; coding: utf-8 -*-
;;  Copyright (C) 2014
;;      "Mu Lei" known as "NalaGinrut" <NalaGinrut@gmail.com>
;;  This file is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.

;;  This file is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.

;;  You should have received a copy of the GNU General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.

(define-module (test parser)
  #:use-module (ice-9 match)
  #:use-module (ice-9 format)
  #:use-module (srfi srfi-1)
  #:use-module (test-suite lib))

;; export all things
(eval-when (eval load compile)
  (export-all-from-module! '(language lua parser)))

(define-syntax-rule (pick-out a b)
  (for-each 
   (lambda (x y)
     (format #t "~a~t===~t~a~t -> ~a~%" x y (equal? x y)))
   a b))

(define *precedence-tests*
  `(("1+2*3/4-5" 
     . (minus 
        (add (number 1) 
             (div 
              (multi (number 2) (number 3))
              (number 4)))
        (number 5)))
    ("(1+2)*3/4-5"
     . (minus 
        (div 
         (multi 
          (add (number 1) (number 2))
          (number 3))
         (number 4))
        (number 5)))
    ("a+i < b/2+1"
     . (lt (add (id "a") (id "i")) 
           (add (div (id "b") (number 2))
                (number 1))))
    ("1+ false or 3"
     ;; NOTE:
     ;; Intended wrong parsing, correct result is (1+false) or 3",
     ;; but such wrong situation possibly occurs, so we test it.
     ;; If it doesn't occur, another potential bug exists.
     . (or (add (number 1) (boolean false)) (number 3)))
    ("5+x^2*8"
     . (add (number 5)
            (multi
             (expt (id "x") (number 2))
             (number 8))))
    ("a < y and y <= z"
     . (and (lt (id "a") (id "y"))
            (leq (id "y") (id "z"))))
    ("-x^2"
     . (uminus (expt (id "x") (number 2))))
    ("x^y^z" ; expt in sequence
     . (expt 
        (expt (id "x") (id "y"))
        (id "z")))
    ("not x ^ 2" ; expt higher than not
     . (not (expt (id "x") (number 2))))
    ("#'123'"
     . (hash (string "123")))
    ("#'123' ^ 2" ; intended wrong exp! 
     ;; expt higher than hash
     ;; so the result is to get length from a number which should be wrong.
     . (hash (expt (string "123") (number 2))))
    
    ))

(define *expr-tests*
  `(;; TODO:
    ;; The expr shouldn't be splited by comma, but asssign does, so modify
    ;; these tests to proper one.
    ;;("1+2,3+4"
    ;; . (begin (add (number 1) (number 2)) (add (number 3) (number 4))))
    ;;("1+2,3+4 and false,true"
    ;; . (begin (add (number 1) (number 2)) 
    ;;          (begin (and (add (number 3) (number 4))
    ;;                      (boolean false))
    ;;                 (boolean true))))
    ("1+2+4*3-2-1-5/8"
     . (minus 
        (minus 
         (minus 
          (add 
           (add (number 1) 
                (number 2))
           (multi (number 4) (number 3)))
          (number 2))
         (number 1))
        (div (number 5) 
             (number 8))))
    ("nil" . (marker nil))
    ("a=1+2" . (assign (id "a") (add (number 1) (number 2))))
    ;; ("a = b + c
     ;; (print or io.write)('done')"
     ;; NOTE: According to the manual 5.2
     ;; The current parser always sees such constructions in the first way,
     ;; interpreting the open parenthesis as the start of the arguments to a call. 
     ;;. ())
    ("\"this is string\"" . (string "this is string"))
    ("'this is string'" . (string "this is string"))
    ("a['xx']['x']+2"
     . (add (array (array (id "a") (string "xx")) (string "x")) (number 2)))))

(define *stat-tests*
  `(("while a<2 do print(a) a=a-1 end"
     . (while (lt (id "a") (number 2))
         do 
         (scope
          (begin 
            (func (id "print") (args (id "a")))
            (assign (id "a") 
                    (minus (id "a") (number 1)))))))
    ("do a=1+2 print(a) end"
     . (block 
        (scope 
         (begin
           (assign (id "a") (add (number 1) (number 2)))
           (func (id "print") (args (id "a")))))))
    ("for a=1,10 do print(a) end"
     . (rep
        (scope
         (for 
          (assign (id "a") (range (number 1) (number 10))))
         (scope 
          (func (id "print") (args (id "a")))))))
    ("for a=1,10,2 do print(a) end"
     . (rep 
        (scope 
         (for (assign (id "a") (range (number 1) (number 10) (number 2))))
         (scope (func (id "print") (args (id "a")))))))
    ("pairs({x=1,y=2})"
     . (func (id "pairs") 
             (args 
              (table (tb-key-set! (id "x") (number 1))
                     (tb-key-set! (id "y") (number 2))))))
    ("for a,b in pairs({x=1,y=2}) do print(a) print(b) end"
     . (rep 
        (scope 
         (for 
          (assign (multi-names (id "a") (id "b")) 
                  (func (id "pairs")
                        (args (table (tb-key-set! (id "x") (number 1))
                                     (tb-key-set! (id "y") (number 2)))))))
         (scope 
          (begin (func (id "print") (args (id "a"))) 
                 (func (id "print") (args (id "b"))))))))
    ("return 1"
     . (return (number 1)))
    ("x=1 return x+1"
     . (begin (assign (id "x") (number 1))
              (return (add (id "x") (number 1)))))
    ))

;; NOTE: Part of these tests are fake since statment can't be exp.
;;       But we need this extra grammar for easier testing.
;; FIXME: maybe remove exp as statment after mature.
(define *cond-tests*
  `(("if true then false end"
     . (if (boolean true) then (scope (boolean false))))
    ("if 1 then 2 elseif 3 then 4 end"
     . (if (number 1) 
           then (scope (number 2))
           elseif (number 3)
           then (scope (number 4))))
    ("if 1 then 2 elseif 3 then 4 elseif 5 then 6 end"
     . (if (number 1) 
           then (scope (number 2))
           elseif (number 3)
           then(scope (number 4))
           elseif (number 5)
           then (scope (number 6))))
    ))

(define *func-tests*
  `(("function a(x) return 1+x end"
     . (func (id "a")
             (scope 
              (params (id "x"))
              (scope (return (add (number 1) (id "x")))))))
    ))

;; This is useful to drop `scope' symbol which should exist
;; in every header of statment.      
(define get-stat cadr)

(define (test-it name tests tests-name)
  (define len (length tests))
  (for-each
   (lambda (t i)
     ;;(display i)(newline)
     (match t
       ((src . expect)
        (let ((r (get-stat (call-with-input-string src read-lua))))
          (or (equal? r expect)
              (error (format #f "~a[~d]: Failed: ~a~%%%%~%~a" name i src (pick-out expect r))))))
       (else (error (format #f "Invalid case in ~a[~d]" tests-name i) t))))
   tests (iota len))
  (format #t "* testing ~d case~:p...~%" len))

(display "\n=== Lua parser syntax tests ===\n")

(with-test-prefix "Lua parser"

  (pass-if "precedence tests"
    (test-it "precedence tests" *precedence-tests* "*precedence-tests*"))

  (pass-if "expr tests"
    (test-it "expr tests" *expr-tests* "*expr-tests*"))

  (pass-if "stat tests"
    (test-it "stat tests" *stat-tests* "*stat-tests*"))

  (pass-if "cond tests"
    (test-it "cond tests" *cond-tests* "*cond-tests*"))

  (pass-if "func tests"
    (test-it "func tests" *func-tests* "*func-tests*"))

  )

